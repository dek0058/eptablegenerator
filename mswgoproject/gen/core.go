package gen

import (
	"encoding/csv"
	"eptablegenerator/mswgoproject/config"
	"eptablegenerator/table"
	"eptablegenerator/table/xlsx"
	"errors"
	"fmt"
	"log"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"strings"
)

type sheetData struct {
	filename string
	content  string
	rows     [][]string
}

type cellData struct {
	header   string
	typeName string
}

func (d sheetData) createGoFile(destPath string) error {
	path := filepath.Join(destPath, d.filename+".go")
	h, err := os.Create(path)
	if err != nil {
		return err
	}
	defer h.Close()

	_, err = h.WriteString(d.content)
	if err != nil {
		return err
	}

	return nil
}

func (d sheetData) createCSVFile(csvPath string) error {
	path := filepath.Join(csvPath, d.filename+".csv")
	h, err := os.Create(path)
	if err != nil {
		return err
	}

	writer := csv.NewWriter(h)
	defer func() {
		writer.Flush()
		h.Close()
	}()

	if err := writer.WriteAll(d.rows); err != nil {
		return err
	}

	return nil
}

func (d sheetData) Execute(destPath string, csvPath string) error {
	if err := d.createGoFile(destPath); err != nil {
		return err
	}

	if err := d.createCSVFile(csvPath); err != nil {
		return err
	}

	return nil
}

func generate(packageName string, sheetName string, data [][]string) (sheetData, error) {
	if len(data) < 3 {
		log.Printf("Sheet '%s' has insufficient data, skipping.\n", sheetName)
		return sheetData{}, errors.New("insufficient data")
	}

	headers := data[0]
	types := data[1]
	attributes := data[2]

	colmnCount := len(headers)
	rowCount := len(data)
	if len(types) < colmnCount || len(attributes) < colmnCount {
		log.Printf("Sheet '%s' has inconsistent column counts, skipping.\n", sheetName)
		return sheetData{}, errors.New("inconsistent column counts")
	}

	var result sheetData
	result.filename = sheetName

	indexKeyType := ""
	indexKeyName := ""

	imports := map[string]any{
		"encoding/csv": nil,
		"errors":       nil,
		"os":           nil,
	}

	cellDatas := make([]cellData, 0, colmnCount)

	for i, v := range attributes {
		if strings.ToLower(v) == "design" {
			continue
		} else if strings.ToLower(v) == "key" {
			indexKeyType = types[i]
			indexKeyName = headers[i]
		}

		header := headers[i]
		var cellData cellData

		switch types[i] {
		case "boolean":
			cellData.header = header
			cellData.typeName = "bool"

			imports["strconv"] = nil

		case "integer":
			cellData.header = header
			cellData.typeName = "int64"
			imports["strconv"] = nil

		case "number":
			cellData.header = header
			cellData.typeName = "float64"
			imports["strconv"] = nil

		case "string":
			cellData.header = header
			cellData.typeName = "string"

		default:
			continue
		}

		cellDatas = append(cellDatas, cellData)
	}

	if indexKeyType == "" || indexKeyName == "" {
		log.Printf("Sheet '%s' does not have a valid key column, skipping.\n", sheetName)
		return sheetData{}, errors.New("missing key column")
	}

	var content strings.Builder
	content.WriteString("// Code generated by ANY_NAME. DO NOT EDIT.\n")
	content.WriteString("package " + packageName + "\n\n")
	if len(imports) > 0 {
		content.WriteString("import (\n")

		keys := slices.Collect(maps.Keys(imports))
		slices.Sort(keys)
		for _, imp := range keys {
			content.WriteString("\t\"" + imp + "\"\n")
		}
		content.WriteString("\n")
		content.WriteString("\t\"github.com/rs/zerolog/log\"\n")
		content.WriteString(")\n\n")
	}
	content.WriteString("func New" + sheetName + "Table() *" + sheetName + "Table {\n")
	content.WriteString("\treturn &" + sheetName + "Table{records: make(map[" + indexKeyType + "]*" + sheetName + "Record," + fmt.Sprint(rowCount-3) + ")}\n")
	content.WriteString("}\n\n")
	content.WriteString("type " + sheetName + "Table struct {\n")
	content.WriteString("\trecords map[" + indexKeyType + "]*" + sheetName + "Record\n")
	content.WriteString("}\n\n")
	content.WriteString("type " + sheetName + "Record struct {\n")
	for i, cellData := range cellDatas {
		content.WriteString("\t" + cellData.header + " " + cellData.typeName + "\n")
		if i != len(cellDatas)-1 {
			content.WriteString("\n")
		}
	}
	content.WriteString("}\n\n")
	content.WriteString("func (t *" + sheetName + "Table) Load(csvPath string) error {\n")
	content.WriteString("\tvar err error\n")
	content.WriteString("\tfile, err := os.Open(csvPath)\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn err\n")
	content.WriteString("\t}\n")
	content.WriteString("\tdefer file.Close()\n\n")
	content.WriteString("\tr := csv.NewReader(file)\n")
	content.WriteString("\trecords, err := r.ReadAll()\n")
	content.WriteString("\tif err != nil {\n")
	content.WriteString("\t\treturn err\n")
	content.WriteString("\t}\n\n")
	content.WriteString("\tfor _, record := range records[1:] {\n")
	content.WriteString("\t\trec := &" + sheetName + "Record{}\n")
	for i, cellData := range cellDatas {
		switch cellData.typeName {
		case "bool":
			content.WriteString("\t\t{\n")
			content.WriteString("\t\t\tboolVal, err := strconv.ParseBool(record[" + fmt.Sprint(i) + "])\n")
			content.WriteString("\t\t\tif err != nil {\n")
			content.WriteString("\t\t\t\treturn err\n")
			content.WriteString("\t\t\t}\n")
			content.WriteString("\t\t\trec." + cellData.header + " = boolVal\n")
			content.WriteString("\t\t}\n")

		case "int64":
			content.WriteString("\t\t{\n")
			content.WriteString("\t\t\tintVal, err := strconv.ParseInt(record[" + fmt.Sprint(i) + "], 10, 64)\n")
			content.WriteString("\t\t\tif err != nil {\n")
			content.WriteString("\t\t\t\treturn err\n")
			content.WriteString("\t\t\t}\n")
			content.WriteString("\t\t\trec." + cellData.header + " = intVal\n")
			content.WriteString("\t\t}\n")

		case "float64":
			content.WriteString("\t\t{\n")
			content.WriteString("\t\t\tfloatVal, err := strconv.ParseFloat(record[" + fmt.Sprint(i) + "], 64)\n")
			content.WriteString("\t\t\tif err != nil {\n")
			content.WriteString("\t\t\t\treturn err\n")
			content.WriteString("\t\t\t}\n")
			content.WriteString("\t\t\trec." + cellData.header + " = floatVal\n")
			content.WriteString("\t\t}\n")

		case "string":
			content.WriteString("\t\trec." + cellData.header + " = record[" + fmt.Sprint(i) + "]\n")
		}
	}
	content.WriteString("\t\t_, ok := t.records[rec." + indexKeyName + "]\n")
	content.WriteString("\t\tif ok {\n")
	content.WriteString("\t\t\tlog.Printf(\"Duplicate key '%v' found in CSV, skipping record.\\n\", rec." + indexKeyName + ")\n")
	content.WriteString("\t\t\terr = errors.New(\"duplicate key\")\n")
	content.WriteString("\t\t\tcontinue\n")
	content.WriteString("\t\t}\n")
	content.WriteString("\t\tt.records[rec." + indexKeyName + "] = rec\n")
	content.WriteString("\t}\n")
	content.WriteString("\treturn nil\n")
	content.WriteString("}\n\n")
	content.WriteString("func (t *" + sheetName + "Table) Get (key " + indexKeyType + ") (*" + sheetName + "Record, bool) {\n")
	content.WriteString("\trec, ok := t.records[key]\n")
	content.WriteString("\treturn rec, ok\n")
	content.WriteString("}\n\n")

	result.content = content.String()

	// csv 파일 생성
	if len(data) > 0 {
		newDatas := []string{}
		for i := range colmnCount {
			if strings.ToLower(attributes[i]) == "design" {
				continue
			}
			newDatas = append(newDatas, headers[i])
		}
		result.rows = append(result.rows, newDatas)
	}

	for i, row := range data {
		if i < 3 {
			continue
		}

		newDatas := []string{}
		for j := range colmnCount {
			if strings.ToLower(attributes[j]) == "design" {
				continue
			}
			newDatas = append(newDatas, row[j])
		}

		result.rows = append(result.rows, newDatas)
	}

	return result, nil
}

func Generate(c *config.Config) error {
	if c == nil {
		return errors.New("config is nil")
	}

	files, err := table.FindXLSX(c.SourceDir)
	if err != nil {
		return err
	}

	sheetDatas := []sheetData{}
	for _, file := range files {
		x := xlsx.NewXLSX(file)
		if x == nil {
			log.Println("Failed to load XLSX file:", file)
			continue
		}

		for name, data := range x.Data {
			sheetData, err := generate(c.PackageName, name, data)
			if err != nil {
				log.Printf("Failed to generate data for sheet %s in file %s: %v", name, file, err)
				continue
			}

			sheetDatas = append(sheetDatas, sheetData)
		}
	}

	for _, sheetData := range sheetDatas {
		if err := sheetData.Execute(c.DestDir, c.CsvDir); err != nil {
			log.Printf("Failed to execute sheet data for file %s: %v", sheetData.filename, err)
		}
	}

	return nil
}
